BEGIN {
    printf("KERNEL_MONITOR_STARTED container_tracking=fork_based container_birth=enabled\n");
}

// Track all forks to build process lineage
tracepoint:sched:sched_process_fork {
    @ppid[args->child_pid] = args->parent_pid;
    
    // Check if parent is a known runtime process
    if (@is_runtime[args->parent_pid] == 1) {
        @is_runtime[args->child_pid] = 1;
        @runtime_parent[args->child_pid] = args->parent_pid;
    }
    
    // Detect when containerd-shim forks (this is how containers start on GKE)
    if (comm == "containerd-shim") {
        @container_birth_start[args->child_pid] = nsecs;
        @is_runtime[args->child_pid] = 1;
        @runtime_parent[args->child_pid] = pid;
        printf("CONTAINER_FORK pid=%d ppid=%d parent_comm=%s timestamp_ms=%llu\n",
               args->child_pid, pid, comm, nsecs/1000000);
    }
}

// Track exec events for runtime processes (runc/crun)
tracepoint:sched:sched_process_exec {
    $pp = @ppid[pid];
    
    // Mark runc/crun as runtime when they exec
    if (comm == "runc" || comm == "crun") {
        @is_runtime[pid] = 1;
        @container_start[pid] = nsecs;
        @syscall_count[pid] = 0;
        printf("CONTAINER_PROCESS_START pid=%d ppid=%d comm=%s timestamp_ms=%llu\n",
               pid, $pp, comm, nsecs/1000000);
    }
}

// Detect container main process - first non-runtime exec in lineage
tracepoint:sched:sched_process_exec 
/@is_runtime[pid] == 1 && comm != "runc" && comm != "crun" && comm != "containerd-shim" && comm != "containerd-shim-runc-v2"/ {
    $pp = @ppid[pid];
    
    // Note: Cannot get cgroup path on GKE kernel - using PID-based resolution
    printf("CONTAINER_MAIN pid=%d ppid=%d comm=%s timestamp_ms=%llu\n",
           pid, $pp, comm, nsecs/1000000);
    
    // Track this as the main container process
    @container_main_pid[pid] = nsecs;
    @container_syscalls[pid] = 0;
    
    // Stop tracking this lineage after finding container main
    delete(@is_runtime[pid]);
}

// Count syscalls from tracked container runtime processes and main processes
tracepoint:raw_syscalls:sys_enter {
    // Track syscalls for runtime processes
    if (@container_start[pid] > 0) {
        @syscall_count[pid]++;
        
        // Track specific important syscalls for modern container creation
        if (args->id == 272) { // unshare
            @namespace_ops[pid]++;
            printf("CONTAINER_NAMESPACE_OP pid=%d type=unshare timestamp_ms=%llu\n", 
                   pid, nsecs / 1000000);
        } else if (args->id == 165) { // mount
            @mount_ops[pid]++;
            printf("CONTAINER_MOUNT_OP pid=%d type=mount timestamp_ms=%llu\n", 
                   pid, nsecs / 1000000);
        } else if (args->id == 155) { // pivot_root
            @mount_ops[pid]++;
            printf("CONTAINER_MOUNT_OP pid=%d type=pivot_root timestamp_ms=%llu\n", 
                   pid, nsecs / 1000000);
        } else if (args->id == 308) { // setns
            @namespace_ops[pid]++;
            printf("CONTAINER_NAMESPACE_OP pid=%d type=setns timestamp_ms=%llu\n", 
                   pid, nsecs / 1000000);
        } else if (args->id == 56 || args->id == 435) { // clone/clone3
            @namespace_ops[pid]++;
            printf("CONTAINER_NAMESPACE_OP pid=%d type=clone timestamp_ms=%llu\n", 
                   pid, nsecs / 1000000);
        }
        
        // Report progress every 100 syscalls
        if (((uint64)@syscall_count[pid]) % 100 == 0) {
            printf("CONTAINER_SYSCALLS pid=%d total=%d timestamp_ms=%llu\n", 
                   pid, @syscall_count[pid], nsecs / 1000000);
        }
    }
    
    // Track syscalls for container main processes
    if (@container_main_pid[pid] > 0) {
        @container_syscalls[pid]++;
        
        // Report first 100 syscalls of container main
        if (@container_syscalls[pid] <= 100) {
            printf("CONTAINER_MAIN_SYSCALL pid=%d count=%d timestamp_ms=%llu\n",
                   pid, @container_syscalls[pid], nsecs/1000000);
        }
    }
}

// Process exit - cleanup and report if this was a tracked container process
tracepoint:sched:sched_process_exit {
    // Report container birth completion for runc/crun
    if (@container_start[pid] > 0) {
        $duration_ns = nsecs - @container_start[pid];
        $pp = @ppid[pid];
        printf("CONTAINER_BIRTH_COMPLETE pid=%d ppid=%d comm=%s total_syscalls=%d namespace_ops=%d mount_ops=%d duration_ns=%llu timestamp_ms=%llu\n", 
               pid, $pp, comm, @syscall_count[pid], @namespace_ops[pid], @mount_ops[pid], 
               $duration_ns, nsecs / 1000000);
        
        delete(@container_start[pid]);
        delete(@syscall_count[pid]);
        delete(@namespace_ops[pid]);
        delete(@mount_ops[pid]);
    }
    
    // Cleanup all tracking maps
    delete(@ppid[pid]);
    delete(@is_runtime[pid]);
    delete(@container_main_pid[pid]);
    delete(@container_syscalls[pid]);
}